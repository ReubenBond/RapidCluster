using RapidCluster.Pb;

namespace RapidCluster;

/// <summary>
/// Interface for cut detection in the Rapid protocol.
/// Cut detectors aggregate failure/join reports and determine when there is
/// sufficient agreement to propose a view change.
/// 
/// A new cut detector is created for each view, so implementations do not need
/// to support clearing state - they are simply replaced on view change.
/// </summary>
internal interface ICutDetector
{
    /// <summary>
    /// Gets the number of proposals that have been generated by this detector.
    /// </summary>
    int GetNumProposals();

    /// <summary>
    /// Apply an AlertMessage against the cut detector. When sufficient reports
    /// have been received about a node (based on the detector's threshold logic),
    /// the method returns a view change proposal.
    /// </summary>
    /// <param name="msg">An AlertMessage to apply against the detector</param>
    /// <returns>A list of endpoints about which a view change has been recorded. Empty list if there is no proposal.</returns>
    List<Endpoint> AggregateForProposal(AlertMessage msg);

    /// <summary>
    /// Apply a single ring's report from an AlertMessage against the cut detector.
    /// This allows callers to control the order of ring processing across multiple
    /// messages, enabling proper batching of view changes.
    /// 
    /// When processing a batch of alerts, callers should iterate by ring number
    /// (outer loop) and then by message (inner loop) to allow multiple nodes to
    /// accumulate reports together before any reaches the threshold.
    /// </summary>
    /// <param name="msg">An AlertMessage containing the edge information</param>
    /// <param name="ringNumber">The specific ring number to process</param>
    /// <returns>A list of endpoints about which a view change has been recorded. Empty list if there is no proposal.</returns>
    List<Endpoint> AggregateForProposalSingleRing(AlertMessage msg, int ringNumber);

    /// <summary>
    /// Invalidates edges between nodes that are failing or have failed. This step may be skipped safely
    /// when there are no failing nodes.
    /// </summary>
    /// <returns>A list of endpoints representing a view change proposal.</returns>
    List<Endpoint> InvalidateFailingEdges();

    /// <summary>
    /// Gets whether there are nodes in "unstable mode" (between L and H reports).
    /// This is used by the MembershipService to determine if a timeout should be applied.
    /// </summary>
    /// <returns>True if there are nodes in unstable mode, false otherwise.</returns>
    bool HasNodesInUnstableMode();

    /// <summary>
    /// Forces nodes in unstable mode (between L and H reports) to be promoted to the proposal set.
    /// This is called when the unstable mode timeout expires to prevent indefinite blocking.
    /// </summary>
    /// <returns>A list of endpoints that were promoted and are now proposed for view change.</returns>
    List<Endpoint> ForcePromoteUnstableNodes();
}
